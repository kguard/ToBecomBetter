package com.kguard.tobecomebetter.baekjoon

// 골드 3 Contact
// 문자열, 정규 표현식
// 정규 표현식을 사용해서 문제를 해결하면됨
// ^ : 문자열의 시작을 의미.
// $ : 문자열의 끝을 의미.
// . : 문자 한 개를 의미. '.'이 위치한 곳에 어떤 문자든지 1개의 문자가 들어감.
// [ ] : 대괄호에 있는 문자 중 한 개를 의미. [abc]는 a, b, c 중 하나를 선택.
// [^] : not의 의미로, 대괄호에서 쓴다면 [^abc] : a, b, c 제외하고 나머지를 의미.
// | : or을 의미. a|b : a 또는 b.
// () : 공통되는 부분을 묶을 때, 서브 패턴을 지정할 때 사용. abc|abd -> ab(c|d)로 바꿀 수 있음.
// ? : 문자가 0회 또는 1회 등장. a? b는 a가 나올 수도, 없을 수도 있음. ab, b.
// : 문자가 0회 이상 등장. ab : b, ab, aaab, aaab..
// + : 문자가 1회 이상 등장. a+b : ab, aab, aaab..
// {n} : 문자가 n개 나옴. a {2} b : aab
// {n,} : 문자가 n개 이상 나옴. a {2,} b : aab, aaab, aaaab..
// {n, m} : 문자가 n개 이상 m개 이하로 나옴. a {1,3 } b : ab, aab, aaab
// \s : 공백 제거
// \t : 탭
// \d : 숫자, [0-9]와 동일
// \b : 단어의 경계, 문자 사이의 공백
// \w : 알파벳이나 숫자, [a-zA-Z0-9_]와 동일
// 위의 \s, \t, \d, \b, \w는 대문자로 바꾸면 반대 의미가 됩니다.

// 10+ = { 10, 100, 1000, 10000, 100000, … } 에서 10+ 은 0에만 + 가 해당됨
// (10)+ = { 10, 1010, 101010, 10101010, 1010101010, … } 에서 10에 + 해당되서 반복 되게

// 1+ = { 1, 11, 111, 1111, 11111, … }
// 10+ = { 10, 100, 1000, 10000, 100000, … }
// (01)+ = { 01, 0101, 010101, 01010101, 0101010101, … }
// (1001)+ = { 1001, 10011001, 100110011001, … }
// 10+11 = { 1011, 10011, 100011, 1000011, 10000011, … }
// (10+1)+ = { 101, 1001, 10001, 1011001, 1001101, 100011011000001, … }

// { 0+ | 1+ } 는 { 0 , 1 , 00 , 11 , 000 , 111 , … } 에서 0의 반복 이나 1의 반복이 나오면 true
// (100 | 11)+ = { 100 , 11 , 10011 , 11100 , 1110011100 , 100111111100100, … } 에서 100이나 11의 반복이 나오면 됨 (순서는 상관 없음)
fun main(){
    val t = readln().toInt()
    val regex = "(100+1+|01)+".toRegex()
    repeat(t){
        val check = readln()
        if(regex.matches(check)) println("YES") else println("NO")
    }
}