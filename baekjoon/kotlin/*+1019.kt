package com.kguard.tobecomebetter.baekjoon

import kotlin.math.pow

// 플래티넘 5 책 페이지
// 수학, 구현
// 수의 특징을 찾아내서 더하는 문제
// 0부터 9999까지 구했을 떄 각 숫자는 4,000 번씩 나옴 -> n * 10의 n-1승 갯수가 나옴
// 십의 자리씩 끊어서 계산
// ex) 543212345을 기준으로 주석 달기
// 의 방식으로 문제 해결 543212345 = 500000000+ 40000000 + 3000000 + 200000 + 10000 + 2000 + 300 + 40 + 5
// 맨 처음 500000000 으로 문제 풀이 과정 살펴 보기
fun main(){
    val d = MutableList(10){0}
    val n = readln()
    var k = n.length // 9
    for(i in n){
       k -= 1 // 8
       for(j in 0 until i.toString().toInt()) { // 0부터 4 까지 -> 0~4
           d[j] += 10.0.pow(k).toInt() // 제일 큰 자릿수 추가 400000000, 300000000, 200000000, 100000000, 000000000 5개가 올수 있음
           for (t in 0 until 10) // 00000000(8개) ~ 999999999(8개) 번까지 8 * 10의 7승 번 나오게 됨 -> 그 다음 자릿수는 0000000(7개) ~ 9999999(7개) 까지 또 나옴 -> 그래서 반복
               if (k >= 1) // 400000000, 300000000, 200000000, 100000000, 000000000 이니 8 * 10의 7승을 5번 더하는 결과가 됨
                   d[t] += 10.0.pow(k-1).toInt() * k // 8 * 10의 7승
       }
        d[0] -= 10.0.pow(k).toInt() // 아까 더한 제일 큰 자릿수에서 맨 앞은 0이 될 수 없으니 다시 빼주기
        if(k > 0) // 자릿 수가 0 보다 크면 500000000 ~ 543212345까지 5라는 숫자는 43212345 + 1 번 나오게 됨
            d[i.toString().toInt()] += n.takeLast(k).toInt() + 1 // takelast(int) -> 마지막 int개의 숫자를 리스트로 반환해줌
        else // 자릿 수가 0 이면 지금은 1의 자리 라는 뜻 이니 본인이 마지막에 나오는 하나를 더하면 됨
            d[i.toString().toInt()] += 1
    }
    d.forEach { print("$it ") }
}