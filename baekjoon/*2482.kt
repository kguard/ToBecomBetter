package com.kguard.tobecomebetter.baekjoon

// 골드 3 색상환
// 다이나믹 프로그래밍
// dp[N][K] (N: 현재 보고 있는 색, K: 현재까지 선택한 수) -> 결국 모든 경우의 수를 구하게 됨
// n개의 색중에 k를 골라야 하는 문제, 원형으로 이루어져 있음
// 두 가지 경우의 수를 더하면 됨 : 1. 자기 자신을 뽑을 경우의 수, 2. 자기 자신을 뽑지 않을 경우의 수
// 자기 자신은 뽑으면 바로 전 색은 못뽑으니 개수 n-2 개 중 자기 자신을 제외한 색 1개이니 k-1개 를 뽑기
// 자기 자신을 뽑지 않으려면 바로 전 색을 뽑으면 되니 n-1 개중 k개를 뽑으면 됨
// 경우의 수 방식으로 접근하면 풀수 있는 문제
fun main() {
    val n = readln().toInt()
    val k = readln().toInt()
    val dp = MutableList(n + 1) { MutableList(k + 1) { 0 } }
    for (i in 0 .. n) {
        dp[i][0] = 1 // 아무것도 안뽑을 경우의 수는 1개
        dp[i][1] = i // n개 중에 1개만 뽑을 수 있는 경우의 수는 n개
    }
    for (i in 2..n) {
        for (j in 2..k) {
            if (i == n)
                dp[i][j] = (dp[i - 3][j - 1] + dp[i - 1][j]) % 1000000003 // 마지막인 n번째 색을 고를 경우에는 n, n-1, 1 번째 색 3개를 고를 수 없음 따라서 n-3개 중에 n번째 색을 뽑았으니 1개를 제외해서 j-1 개의 색을 고르면 됨
            else
                dp[i][j] = (dp[i - 2][j - 1] + dp[i - 1][j]) % 1000000003
        }
        // 자기 자신을 뽑을 경우 -> i,i-1번째 색을 고를 수 없기 때문에 i-2개중에 이미 i번째색을 뽑았으니 1개를 제외해서 j-1개를 고르면 됨
        // 자기 자신을 뽑지 않을 경우 -> i-1번째 색을 고른 경우의 수와 같은 경우의 수 이니 i-1개 중에 j개의 색을 뽑으면 됨
    }
    println(dp[n][k])
}